!function(t){var e={};function s(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,s),i.l=!0,i.exports}s.m=t,s.c=e,s.i=function(t){return t},s.d=function(t,e,n){s.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=20)}([function(t,e,s){"use strict";class n{static distance(t,e){const s=e.x-t.x,n=e.y-t.y;return Math.sqrt(Math.pow(s,2)+Math.pow(n,2))}static angleInRad(t,e){const s=e.x-t.x,n=e.y-t.y,i=Math.atan2(n,s);return i>=0?i:i+2*Math.PI}static angleInDegree(t,e){return n.toDegree(this.angleInRad(t,e))}static rotateEnd(t,e,s){const i=n.distance(t,e),r=n.angleInDegree(t,e)+s,a=n.toRad(r),o=Math.cos(a)*i,h=Math.sin(a)*i;return{x:t.x+o,y:t.y+h}}static reduceEnd(t,e,s){const i=n.angleInRad(t,e),r=Math.cos(i)*s,a=Math.sin(i)*s;return{x:e.x-r,y:e.y-a}}static toDegree(t){return 180*t/Math.PI}static toRad(t){return t*Math.PI/180}static intersectSegmentCircle(t,e,s,i){const r=e.x-t.x,a=e.y-t.y,o=Math.pow(r,2)+Math.pow(a,2);if(0===o)return n.distance(t,e)<=s.radius+i;const h=-2*(Math.pow(t.x,2)-t.x*e.x-t.x*s.x+e.x*s.x+Math.pow(t.y,2)-t.y*e.y-t.y*s.y+e.y*s.y),c=Math.min(-h/(2*o),1);if(c<0)return!1;const d=t.x+r*c,l=t.y+a*c;return n.distance({x:d,y:l},s)<=s.radius+i}}t.exports=n},function(t,e,s){"use strict";const n=s(18);let i;t.exports=class{static init(t){i=n.createWriteStream(t,{flags:"w"})}static log(t){i.write(t+"\n")}}},function(t,e,s){"use strict";t.exports={MAX_SPEED:7,SHIP_RADIUS:.5,MAX_SHIP_HEALTH:255,BASE_SHIP_HEALTH:255,WEAPON_COOLDOWN:1,WEAPON_RADIUS:5,WEAPON_DAMAGE:64,EXPLOSION_RADIUS:10,DOCK_RADIUS:4,DOCK_TURNS:5,BASE_PRODUCTIVITY:6,SPAWN_RADIUS:2}},function(t,e,s){"use strict";const n=s(0),i=s(2),r=(s(1),s(4));t.exports=new class{constructor(){this.previousMap=null,i.PLANET_AROUND_RADIUS=i.MAX_SPEED+i.WEAPON_RADIUS+2*i.SHIP_RADIUS,i.SAFE_DISTANCE=.1}GetSortPlanets(t){return this.gameMap.planets.filter(t=>t.isFree()||t.isOwnedByMe()&&t.hasDockingSpot()).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetSortEnemies(t){return this.gameMap.enemyShips.sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetNearestPlanet(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this.GetSortPlanets(t);return e<s.length?s[e]:null}GetNearestEnemy(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this.GetSortEnemies(t);return e<s.length?s[e]:null}GetEnemiesAroundTarget(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;return this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(s=>n.distance(t,s)<e).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetAlliesAroundTarget(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;return this.gameMap.myShips.filter(t=>t.isUndocked()).filter(s=>n.distance(s,t)<e).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetAttackingEnemies(t){return attackingEnemies=this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(e=>this.IsEnemyAttackingPlanet(e,t)).filter(e=>0===this.gameMap.planetsBetween(e,t).length)}GetHarassEnemies(t){return this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(t=>this.GetEnemiesAroundTarget(t,10).length<5).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}IsShipAroundPlanet(t,e){return n.distance(t,e)<e.radius+i.DOCK_RADIUS+i.PLANET_AROUND_RADIUS}IsEnemyAttackingPlanet(t,e){const s=this.gameMap.previous.shipById(t.id);if(!s)return!1;const a=r.VectorNormalize({x:t.x-s.x,y:t.y-s.y}),o={x:t.x+a.x*i.MAX_SPEED,y:t.y+a.y*i.MAX_SPEED};return n.intersectSegmentCircle(t,o,e,i.DOCK_RADIUS+i.SHIP_RADIUS+3)||this.IsShipAroundPlanet(t,e)}GetEnemyAngle(t){const e=this.gameMap.previous.shipById(t.id);if(!e)return null;const s=r.VectorNormalize({x:t.x-e.x,y:t.y-e.y}),a={x:t.x+s.x*i.MAX_SPEED,y:t.y+s.y*i.MAX_SPEED};return n.angleInDegree(t,a)}Update(t){this.previousMap?(delete this.previousMap.previous,t.previous=this.previousMap):t.previous=t,this.gameMap=t,this.previousMap=t}}},function(t,e,s){"use strict";const n=s(0),i=s(2);s(1);class r{static VectorNormalize(t){const e=Math.sqrt(t.x*t.x+t.y*t.y);return{x:t.x/e,y:t.y/e}}static VectorFromSpeedAngle(t,e){const s=n.toRad(e);return{x:t*Math.cos(s),y:t*Math.sin(s)}}static PositionInNextTurn(t,e,s){const n=r.VectorFromSpeedAngle(e||t.speed,s||t.angle);return{x:t.x+n.x,y:t.y+n.y,radius:0}}static IsTwoLinesIntersect(t,e,s,n){let i=e.x-t.x,r=e.y-t.y,a=n.x-s.x,o=n.y-s.y,h=(-r*(t.x-s.x)+i*(t.y-s.y))/(-a*r+i*o),c=(+a*(t.y-s.y)-o*(t.x-s.x))/(-a*r+i*o);return h>=0&&h<=1&&c>=0&&c<=1}static TangentToCircleFromCircle(t,e){const s=e.x-t.x,n=e.y-t.y,r=Math.sqrt(s*s+n*n),a=Math.asin(e.radius/r),o=Math.atan2(n,s),h=t.radius+e.radius+i.SHIP_RADIUS+i.SAFE_DISTANCE,c=o-a,d=o+a;return{p1:{x:e.x+h*Math.sin(c),y:e.y-h*Math.cos(c)},p2:{x:e.x-h*Math.sin(d),y:e.y+h*Math.cos(d)}}}static GetCenterPointFromGroup(t){if(1==t.length)return t[0];const e=t.sort((t,e)=>t.x-e.x).map(t=>t.x),s=t.sort((t,e)=>t.y-e.y).map(t=>t.y),n=e[0],i=s[0],r=e[e.length-1]-e[0],a=s[s.length-1]-s[0];return{x:n+r/2,y:i+a/2,radius:Math.sqrt(r*r+a*a)/2}}static AngleBetween(t,e){return r.Mod(e-t+180,360)-180}static Mod(t,e){return t-Math.floor(t/e)*e}}t.exports=r},function(t,e,s){"use strict";t.exports={UNDOCKED:0,DOCKING:1,DOCKED:2,UNDOCKING:3}},function(t,e,s){"use strict";const n=s(0);t.exports=class{constructor(t){this._params=t}get id(){return this._params.id}get x(){return this._params.x}get y(){return this._params.y}get radius(){return this._params.radius}get health(){return this._params.health}distanceBetween(t){return n.distance(this,t)}angleBetweenInDegree(t){return n.angleInDegree(this,t)}}},function(t,e,s){"use strict";const n=s(6);t.exports=class extends n{constructor(t,e){super(e),this._params=e,this._gameMap=t}isOwned(){return null!==this.ownerId&&void 0!==this.ownerId}isOwnedByMe(){return this.ownerId===this._gameMap.myPlayerId}isOwnedByEnemy(){return this.isOwned()&&this.ownerId!==this._gameMap.myPlayerId}isFree(){return null===this.ownerId||void 0===this.ownerId}get ownerId(){return this._params.ownerId}get dockingSpots(){return this._params.dockingSpots}hasDockingSpot(){return this.numberOfDockedShips<this._params.dockingSpots}get currentProduction(){return this._params.currentProduction}get remainingProduction(){return this._params.remainingProduction}get dockedShipIds(){return this._params.dockedShipIds}get numberOfDockedShips(){return this.dockedShipIds.length}get dockedShips(){return this._gameMap.shipsByIds(this.dockedShipIds)}toString(){return"planer. "+(this.ownerId?"owner id: "+this.ownerId:"no owner")+": "+JSON.stringify(this._params)}}},function(t,e,s){"use strict";const n=s(0),i=s(2),r=(s(1),s(4));class a{static IsCollidesWithObstacleInNextTurn(t,e,s,a){const o=r.PositionInNextTurn(t,e,s);return a.filter(e=>t!=e).some(e=>n.intersectSegmentCircle(t,o,e,i.SHIP_RADIUS+i.SAFE_DISTANCE))}static AvoidCollidesWithWall(t,e){const s=r.PositionInNextTurn(t,t.speed,t.angle);s.x<=0?t.angle=-90:s.x>=e.width?t.angle=90:s.y<=0?t.angle=0:s.y>=e.height&&(t.angle=180)}static AvoidCrashWhenMovingToTarget(t,e){e.filter(e=>t.id!=e.id).filter(e=>n.distance(t,e)<=2*(i.MAX_SPEED+i.SHIP_RADIUS)).filter(e=>{const s=r.PositionInNextTurn(t),a=r.PositionInNextTurn(e),o=n.distance(s,a)<=2*i.SHIP_RADIUS+1||r.IsTwoLinesIntersect(t,s,e,a);return o}).length>0&&t.speed>0&&(t.angle,t.speed=Math.max(0,t.speed-1),a.AvoidCrashWhenMovingToTarget(t,e))}static AvoidCollidesWithObstacles(t,e){const s=r.PositionInNextTurn(t);e.filter(e=>t!=e).filter(e=>n.intersectSegmentCircle(t,s,e,i.SHIP_RADIUS+i.SAFE_DISTANCE)).forEach(s=>{const i=r.TangentToCircleFromCircle(t,s),o=n.angleInDegree(t,i.p1),h=n.angleInDegree(t,i.p2),c=a.IsCollidesWithObstacleInNextTurn(t,t.speed,o,e),d=a.IsCollidesWithObstacleInNextTurn(t,t.speed,h,e);if(c&&!d||!c&&d)t.angle=c?h:o;else if(c||d)t.speed>0&&(t.speed=Math.max(0,t.speed-1),a.AvoidCollidesWithObstacles(t,e));else{const e=Math.abs(r.AngleBetween(o,t.angle)),s=Math.abs(r.AngleBetween(h,t.angle));t.angle=e<s?o:h}})}static AvoidCollidesWithEnemies(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const o=r.PositionInNextTurn(t),h=e.filter(e=>t!=e).filter(e=>n.intersectSegmentCircle(t,o,e,i.SHIP_RADIUS+i.SAFE_DISTANCE));let c=!1;for(let s=0;s<h.length;s++){const i=h[s],o=r.TangentToCircleFromCircle(t,i),d=n.angleInDegree(t,o.p1),l=n.angleInDegree(t,o.p2),p=a.IsCollidesWithObstacleInNextTurn(t,t.speed,d,e),u=a.IsCollidesWithObstacleInNextTurn(t,t.speed,l,e);if(p&&!u||!p&&u)t.angle=p?l:d;else if(p||u)c=!0;else{const e=Math.abs(r.AngleBetween(d,t.angle)),s=Math.abs(r.AngleBetween(l,t.angle));t.angle=e<s?d:l}}c&&s<180&&(t.angle+=2,a.AvoidCollidesWithEnemies(t,e,++s))}}t.exports=a},function(t,e,s){"use strict";const n=s(0),i=s(2),r=(s(1),s(5));t.exports=class{constructor(t){this.ship=t,this.speed=0,this.angle=0,this.task="",this.target=""}get id(){return this.ship.id}get x(){return this.ship.x}get y(){return this.ship.y}get radius(){return i.SHIP_RADIUS}get ownerId(){return this.ship._ownerId}get dockingStatus(){return this.ship.dockingStatus}get dockedPlanetId(){return this.ship.dockedPlanetId}get dockingProgress(){return this.ship.dockingProgress}get weaponCooldown(){return this.ship.weaponCooldown}isDocked(){return this.ship.dockingStatus===r.DOCKED}isDocking(){return this.ship.dockingStatus===r.DOCKING}isUndocking(){return this.ship.dockingStatus===r.UNDOCKING}isUndocked(){return this.ship.dockingStatus===r.UNDOCKED}canDock(t){return n.distance(this.ship,t)<=i.SHIP_RADIUS+t.radius+i.DOCK_RADIUS&&t.hasDockingSpot()&&(t.isFree()||t.ownerId===this.ship.ownerId)}PrepareForMoveTo(t,e,s){const i=n.reduceEnd(this.ship,t,s),r=n.distance(this.ship,i);this.angle=n.angleInDegree(this.ship,i),this.speed=e<=r?e:r,this.task="move"}PrepareForDockTo(t){this.planet=t,this.task="dock"}DoCommand(){switch(this.task){case"move":return this.ship.thrust(this.speed,this.angle);case"dock":return this.ship.dock(this.planet)}}}},function(t,e,s){"use strict";const n=s(1),i=s(14),r=s(13);let a=null;t.exports=class{static start(t){let e=t.botName,s=t.preProcessing,o=t.strategy,h=1;i.readNLines(2,t=>{const c=function(t){const e=parseInt(t[0]),s=t[1].trim().split(" ");return{myPlayerId:e,width:parseInt(s[0]),height:parseInt(s[1])}}(t);n.init(e+c.myPlayerId+".log"),n.log("game meta:"),t.forEach(t=>n.log(t)),n.log(JSON.stringify(c)),a=new r(c),i.readLine(t=>{const r=a.parse(t);n.log("initial map:"),n.log(t),s&&s(r),i.writeLine(e),i.forEachReadLine(t=>{n.log(`turn #${h}, map:`),n.log(t);const e=a.parse(t),s=o(e);i.sendMoves(s.filter(t=>null!==t)),n.log("moves:"),n.log(s.join(" ")),h++})})})}}},function(t,e,s){"use strict";const n=s(3),i=s(16),r=s(17);t.exports={Main:function(t){return n.Update(t),new i(t).Update()},MainImprove:function(t){return n.Update(t),new r(t).Update()}}},function(t,e,s){"use strict";const n=s(15),i=s(7),r=s(0);s(2);t.exports=class{constructor(t){let e=t.myPlayerId,s=t.width,n=t.height;this._myPlayerId=e,this._width=s,this._height=n,this._playerIds=[],this._planets=[],this._ships=[],this._shipById={},this._enemyShips=[],this._shipsByPlayerId={}}get myPlayerId(){return this._myPlayerId}get width(){return this._width}get height(){return this._height}addPlayerId(t){this._playerIds.push(t)}addPlayerShips(t,e){const s=this._shipsByPlayerId[t]||[],i=e.map(e=>new n(this,t,e));this._shipsByPlayerId[t]=s.concat(i),t!==this.myPlayerId&&(this._enemyShips=this._enemyShips.concat(i)),this._ships=this._ships.concat(i),i.forEach(t=>this._shipById[t.id]=t)}addPlanets(t){this._planets=this._planets.concat(t.map(t=>new i(this,t)))}get numberOfPlayers(){return this._playerIds.length}get allShips(){return this._ships}get myShips(){return this.playerShips(this.myPlayerId)}get enemyShips(){return this._enemyShips}playerShips(t){return this._shipsByPlayerId[t]||[]}shipById(t){return this._shipById[t]}shipsByIds(t){return t.map(t=>this.shipById(t))}get planets(){return this._planets}shipsBetween(t,e){return this._obstaclesBetween(this.allShips,t,e)}myShipsBetween(t,e){return this._obstaclesBetween(this.myShips,t,e)}enemyShipsBetween(t,e){return this._obstaclesBetween(this.enemyShips,t,e)}planetsBetween(t,e){return this._obstaclesBetween(this.planets,t,e)}obstaclesBetween(t,e){return this.shipsBetween(t,e).concat(this.planetsBetween(t,e))}_obstaclesBetween(t,e,s){return t.filter(t=>t.id!==e.id&&t.id!==s.id).filter(t=>r.intersectSegmentCircle(e,s,t,e.radius+.2))}}},function(t,e,s){"use strict";const n=s(12);function i(t,e){const s=[];for(let n=0;n<t;n++)s.push(e(n));return s}t.exports=class{constructor(t){let e=t.myPlayerId,s=t.width,n=t.height;this._myPlayerId=e,this._width=s,this._height=n}parse(t){this._tokens=t.trim().split(" "),this._currentIdx=0,this.map=new n({myPlayerId:this._myPlayerId,width:this._width,height:this._height}),this._parsePlayers(),this._parsePlanets();const e=this._remainingTokens();if(0!==e.length)throw new Error("detected unprocessed remaining tokens: "+e);return this.map}_parsePlayers(){!function(t,e){for(let s=0;s<t;s++)e(s)}(this._nextInt(),()=>{const t=this._nextInt();this.map.addPlayerId(t),this._parseShips(t)})}_parseShips(t){const e=i(this._nextInt(),()=>this._nextShipParams());this.map.addPlayerShips(t,e)}_parsePlanets(){const t=i(this._nextInt(),()=>this._nextPlanetParams());this.map.addPlanets(t)}_nextShipParams(){return{id:this._nextInt(),x:this._nextFloat(),y:this._nextFloat(),health:this._nextInt(),velocityX:this._nextFloat(),velocityY:this._nextFloat(),dockingStatus:this._nextInt(),dockedPlanetId:this._nextInt(),dockingProgress:this._nextInt(),weaponCooldown:this._nextInt()}}_nextPlanetParams(){return{id:this._nextInt(),x:this._nextFloat(),y:this._nextFloat(),health:this._nextInt(),radius:this._nextFloat(),dockingSpots:this._nextInt(),currentProduction:this._nextInt(),remainingProduction:this._nextInt(),ownerId:1===this._nextInt()?this._nextInt():this._skipNextAndReturn(null),dockedShipIds:this._nextDockedShipIds()}}_nextDockedShipIds(){return i(this._nextInt(),()=>this._nextInt())}_nextInt(){return parseInt(this._nextToken())}_nextFloat(){return parseFloat(this._nextToken())}_skipNextAndReturn(t){return this._nextToken(),t}_nextToken(){return this._tokens[this._currentIdx++]}_remainingTokens(){return this._tokens.slice(this._currentIdx)}}},function(t,e,s){"use strict";const n=s(19).createInterface({input:process.stdin,output:process.stdout});class i{static writeLine(t){process.stdout.write(t+"\n")}static sendMoves(t){i.writeLine(t.join(" "))}static readNLines(t,e){const s=[];function i(){n.question("",r)}function r(n){s.push(n),s.length===t?e(s):i()}i()}static readLine(t){i.readNLines(1,e=>t(e[0]))}static forEachReadLine(t){n.on("line",e=>{t(e)})}}t.exports=i},function(t,e,s){"use strict";var n=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&(t[n]=s[n])}return t};const i=s(0),r=s(6),a=s(2),o=s(5);t.exports=class extends r{constructor(t,e,s){super(s),this._gameMap=t,this._ownerId=e,this._params=n({health:a.BASE_SHIP_HEALTH,dockingStatus:o.UNDOCKED},s)}isDocked(){return this.dockingStatus===o.DOCKED}isDocking(){return this.dockingStatus===o.DOCKING}isUndocking(){return this.dockingStatus===o.UNDOCKING}isUndocked(){return this.dockingStatus===o.UNDOCKED}canDock(t){return i.distance(this,t)<=a.SHIP_RADIUS+t.radius+a.DOCK_RADIUS&&t.hasDockingSpot()&&(t.isFree()||t.ownerId===this.ownerId)}get ownerId(){return this._ownerId}get dockingStatus(){return this._params.dockingStatus}get radius(){return a.SHIP_RADIUS}get dockedPlanetId(){return this._params.dockedPlanetId}get dockingProgress(){return this._params.dockingProgress}get weaponCooldown(){return this._params.weaponCooldown}pointApproaching(t,e){return i.reduceEnd(this,t,e)}dock(t){return`d ${this.id} ${t.id}`}unDock(){return`u ${this.id}`}thrust(t,e){return`t ${this.id} ${0|t} ${0|e}`}navigate(t){let e=t.target;var s=t.keepDistanceToTarget;let n=void 0===s?0:s,r=t.speed;var a=t.avoidObstacles;let o=void 0===a||a;var h=t.maxCorrections;let c=void 0===h?90:h;var d=t.angularStep;let l=void 0===d?1:d;var p=t.ignoreShips;let u=void 0!==p&&p;var g=t.ignorePlanets;let I=void 0!==g&&g;if(c<=0)return null;if(o&&(u&&I?[]:I||u?u?this._gameMap.planetsBetween(this,e):I?this._gameMap.shipsBetween(this,e):[]:this._gameMap.obstaclesBetween(this,e)).length)return this.navigate({target:i.rotateEnd(this,e,l),keepDistanceToTarget:n,speed:r,avoidObstacles:o,maxCorrections:c-1,angularStep:l,ignoreShips:u,ignorePlanets:I});const m=i.reduceEnd(this,e,n),_=this.distanceBetween(m),y=this.angleBetweenInDegree(m),S=_>=r?r:_;return this.thrust(S,y)}toString(){return"ship. owner id: "+this.ownerId+": "+JSON.stringify(this._params)}}},function(t,e,s){"use strict";const n=s(2),i=s(0),r=(s(1),s(7)),a=s(3),o=s(8),h=s(9);t.exports=class{constructor(t){this.gameMap=t}Update(){const t=this.gameMap.myShips.map(t=>new h(t)),e=(this.gameMap.planets.filter(t=>t.isOwnedByMe()).filter(t=>this.gameMap.enemyShips.filter(t=>t.isUndocked()).some(e=>a.IsEnemyAttackingPlanet(e,t))),t.filter(t=>t.isUndocked()).map(t=>{let e=a.GetNearestEnemy(t),s=a.GetNearestPlanet(t),o=null;if(null!=(o=null==e?s:null==s?e:i.distance(t,e)<i.distance(t,s)?e:s.hasDockingSpot()?s:e))return o instanceof r?t.canDock(o)?(t.PrepareForDockTo(o),t):(t.PrepareForMoveTo(o,n.MAX_SPEED,o.radius+t.radius+.05),t):(t.PrepareForMoveTo(o,n.MAX_SPEED,n.WEAPON_RADIUS),t)})),s=t.concat(this.gameMap.planets);return e.forEach(t=>o.AvoidCollidesWithWall(t,this.gameMap)),e.forEach(t=>o.AvoidCollidesWithObstacles(t,s)),e.forEach(t=>o.AvoidCrashWhenMovingToTarget(t,e)),e.map(t=>t.DoCommand())}}},function(t,e,s){"use strict";const n=s(2),i=s(0),r=(s(1),s(4),s(3)),a=s(8),o=s(9);t.exports=class{constructor(t){this.gameMap=t,this.maxDistance=i.distance({x:0,y:0},{x:t.width,y:t.height}),this.shipActions={},this.shipAssignToPlanet={},this.shipAssignAttackEnemy={},this.shipAssignDefHarass={},this.harassShipCount=Math.floor(.1*this.gameMap.myShips.length)}AddAction(t,e){this.shipActions[t.id]||(this.shipActions[t.id]=[]),this.shipActions[t.id].push(e)}IsShipHasAction(t,e){return this.shipActions[t.id].filter(t=>t.type==e).length>0}AssignShipDockToPlanet(t,e){if(this.shipAssignToPlanet[e.id]||(this.shipAssignToPlanet[e.id]=0),this.shipAssignToPlanet[e.id]<e.dockingSpots){if(this.shipAssignToPlanet[e.id]++,t.canDock(e))this.AddAction(t,{type:"dock",target:e,score:this.maxDistance});else{const s=this.maxDistance-i.distance(t,e);this.AddAction(t,{type:"move",target:e,speed:n.MAX_SPEED,distance:1,score:s})}return!0}return!1}AssignShipAttackEnemy(t,e){const s=this.maxDistance-i.distance(t,e);this.AddAction(t,{type:"attack",target:e,speed:n.MAX_SPEED,distance:n.WEAPON_RADIUS,score:s})}AssignShipProtectPlanet(t,e){}WhatShouldIDo(t){const e=r.GetSortPlanets(t);if(e.length>0){let s=0,n=e[s];for(;!this.AssignShipDockToPlanet(t,n)&&(s++,e.length>s);)n=e[s]}this.gameMap.planets.filter(t=>t.isOwnedByMe());const s=r.GetSortEnemies(t);s.length>0&&this.AssignShipAttackEnemy(t,s[0]);{const e=this.gameMap.enemyShips.filter(t=>t.isDocked()).sort((e,s)=>i.distance(t,e)-i.distance(t,s));if(e.length>0){const s=this.maxDistance-i.distance(t,e[0]);this.AddAction(t,{type:"harass",target:e[0],speed:n.MAX_SPEED,distance:n.WEAPON_RADIUS,score:1.3*s}),this.harassShipCount--}}return t}Update(){const t=this.gameMap.myShips.map(t=>new o(t)),e=t.filter(t=>t.isUndocked()).map(t=>this.WhatShouldIDo(t));Object.keys(this.shipActions).forEach(e=>{let s=t.filter(t=>t.id==e)[0];const n=this.shipActions[e];if(n.sort((t,e)=>e.score-t.score),n.length>0){const t=n[0];switch(t.type){case"move":case"group":case"attack":case"harass":case"defense":s.PrepareForMoveTo(t.target,t.speed,t.distance);break;case"dock":s.PrepareForDockTo(t.target)}s.action=t.type}});const s=t.concat(this.gameMap.planets);for(let t=0;t<e.length;t++){let r=e[t];if("harass"==r.action){const t=this.gameMap.enemyShips.filter(t=>t.isUndocked()).map(t=>{const e=i.distance(r,t);return{x:t.x,y:t.y,radius:Math.min(e,n.MAX_SPEED+n.WEAPON_RADIUS)}}).concat(s);a.AvoidCollidesWithEnemies(r,t),r.speed=n.MAX_SPEED}else a.AvoidCollidesWithObstacles(r,s)}return e.forEach(t=>a.AvoidCrashWhenMovingToTarget(t,e)),e.forEach(t=>a.AvoidCollidesWithWall(t,this.gameMap)),e.map(t=>t.DoCommand())}}},function(t,e){t.exports=require("fs")},function(t,e){t.exports=require("readline")},function(t,e,s){"use strict";const n=s(10),i=s(1);const r=s(11).MainImprove;n.start({botName:"Mashimaro Improve",preProcessing:t=>{i.log("no data pre-processing performed. number of ships: "+t.myShips.length)},strategy:r})}]);