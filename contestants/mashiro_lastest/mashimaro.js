!function(t){var e={};function s(i){if(e[i])return e[i].exports;var n=e[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,s),n.l=!0,n.exports}s.m=t,s.c=e,s.i=function(t){return t},s.d=function(t,e,i){s.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=22)}([function(t,e,s){"use strict";class i{static distance(t,e){const s=e.x-t.x,i=e.y-t.y;return Math.sqrt(Math.pow(s,2)+Math.pow(i,2))}static angleInRad(t,e){const s=e.x-t.x,i=e.y-t.y,n=Math.atan2(i,s);return n>=0?n:n+2*Math.PI}static angleInDegree(t,e){return i.toDegree(this.angleInRad(t,e))}static rotateEnd(t,e,s){const n=i.distance(t,e),r=i.angleInDegree(t,e)+s,a=i.toRad(r),o=Math.cos(a)*n,h=Math.sin(a)*n;return{x:t.x+o,y:t.y+h}}static reduceEnd(t,e,s){const n=i.angleInRad(t,e),r=Math.cos(n)*s,a=Math.sin(n)*s;return{x:e.x-r,y:e.y-a}}static toDegree(t){return 180*t/Math.PI}static toRad(t){return t*Math.PI/180}static intersectSegmentCircle(t,e,s,n){const r=e.x-t.x,a=e.y-t.y,o=Math.pow(r,2)+Math.pow(a,2);if(0===o)return i.distance(t,e)<=s.radius+n;const h=-2*(Math.pow(t.x,2)-t.x*e.x-t.x*s.x+e.x*s.x+Math.pow(t.y,2)-t.y*e.y-t.y*s.y+e.y*s.y),c=Math.min(-h/(2*o),1);if(c<0)return!1;const d=t.x+r*c,l=t.y+a*c;return i.distance({x:d,y:l},s)<=s.radius+n}}t.exports=i},function(t,e,s){"use strict";const i=s(20);let n;t.exports=class{static init(t){n=i.createWriteStream(t,{flags:"w"})}static log(t){n.write(t+"\n")}}},function(t,e,s){"use strict";t.exports={MAX_SPEED:7,SHIP_RADIUS:.5,MAX_SHIP_HEALTH:255,BASE_SHIP_HEALTH:255,WEAPON_COOLDOWN:1,WEAPON_RADIUS:5,WEAPON_DAMAGE:64,EXPLOSION_RADIUS:10,DOCK_RADIUS:4,DOCK_TURNS:5,BASE_PRODUCTIVITY:6,SPAWN_RADIUS:2}},function(t,e,s){"use strict";const i=s(0),n=s(2);s(1);class r{static VectorNormalize(t,e){const s=e.x-t.x,i=e.y-t.y,n=Math.sqrt(s*s+i*i);return n>0?{x:s/n,y:i/n,length:n}:{x:0,y:0,length:0}}static VectorFromSpeedAngle(t,e){const s=i.toRad(e);return{x:t*Math.cos(s),y:t*Math.sin(s)}}static PositionInNextTurn(t,e,s){const i=r.VectorFromSpeedAngle(e||t.speed,s||t.angle);return{x:t.x+i.x,y:t.y+i.y,radius:t.radius}}static IsTwoLinesIntersect(t,e,s,i){let n=e.x-t.x,r=e.y-t.y,a=i.x-s.x,o=i.y-s.y,h=(-r*(t.x-s.x)+n*(t.y-s.y))/(-a*r+n*o),c=(+a*(t.y-s.y)-o*(t.x-s.x))/(-a*r+n*o);return h>=0&&h<=1&&c>=0&&c<=1}static TangentToCircleFromCircle(t,e){const s=e.x-t.x,i=e.y-t.y,r=Math.sqrt(s*s+i*i),a=Math.asin(e.radius/r),o=Math.atan2(i,s),h=t.radius+e.radius+(t.radius+n.SAFE_DISTANCE),c=o-a,d=o+a;return{p1:{x:e.x+h*Math.sin(c),y:e.y-h*Math.cos(c)},p2:{x:e.x-h*Math.sin(d),y:e.y+h*Math.cos(d)}}}static IsOutOfScreen(t,e){const s=4*n.SHIP_RADIUS+n.SAFE_DISTANCE;return t.x<=s||t.x>=e.width-s||t.y<=s||t.y>=e.height-s}static IsCollisionTime(t,e,s,a){const o=r.VectorNormalize(t,e),h=r.VectorNormalize(s,a),c=n.MAX_SPEED,d=1/c;for(let e=1;e<=c;e++){const r=t.x+o.x*o.length*d*e,a=t.y+o.y*o.length*d*e,c=s.x+h.x*h.length*d*e,l=s.y+h.y*h.length*d*e,p={x:r,y:a,radius:t.radius},u={x:c,y:l,radius:s.radius};if(i.distance(p,u)<p.radius+u.radius+n.SAFE_DISTANCE_COLLISION_TIME)return!0}return!1}static GetCenterPointFromGroup(t){if(1==t.length)return t[0];const e=t.sort((t,e)=>t.x-e.x).map(t=>t.x),s=t.sort((t,e)=>t.y-e.y).map(t=>t.y),i=e[0],r=s[0],a=e[e.length-1]-e[0]+2*n.SHIP_RADIUS,o=s[s.length-1]-s[0]+2*n.SHIP_RADIUS;return{x:i+a/2,y:r+o/2,radius:Math.sqrt(a*a+o*o)/2+.1}}static GetCenterPointFromSegment(t,e){const s=(e.x-t.x)/2,i=(e.y-t.y)/2;return{x:t.x+s,y:t.y+i,radius:0}}static AngleBetween(t,e){return r.Mod(e-t+180,360)-180}static Mod(t,e){return t-Math.floor(t/e)*e}}t.exports=r},function(t,e,s){"use strict";const i=s(0),n=s(2),r=(s(1),s(3));t.exports=new class{constructor(){this.previousMap=null,n.PLANET_AROUND_RADIUS=2*n.MAX_SPEED+n.WEAPON_RADIUS+2*n.SHIP_RADIUS,n.SAFE_DISTANCE=.01,n.SAFE_DISTANCE_COLLISION_TIME=.2}GetSortPlanets(t){return this.gameMap.planets.filter(t=>t.isFree()||t.isOwnedByMe()&&t.hasDockingSpot()).sort((e,s)=>i.distance(t,e)-i.distance(t,s))}GetSortEnemies(t){return this.gameMap.enemyShips.sort((e,s)=>i.distance(t,e)-i.distance(t,s))}GetSortAlliesAroundPlanet(t){return this.gameMap.myShips.filter(t=>t.isUndocked()).sort((e,s)=>i.distance(t,e)-i.distance(t,s))}GetNearestPlanet(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this.GetSortPlanets(t);return e<s.length?s[e]:null}GetNearestEnemy(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this.GetSortEnemies(t);return e<s.length?s[e]:null}GetEnemiesAroundTarget(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;return this.gameMap.enemyShips.filter(e=>e!=t).filter(t=>t.isUndocked()).filter(s=>i.distance(t,s)<e).sort((e,s)=>i.distance(t,e)-i.distance(t,s))}GetAlliesAroundTarget(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;return this.gameMap.myShips.filter(e=>e!=t).filter(t=>t.isUndocked()).filter(s=>i.distance(s,t)<e).sort((e,s)=>i.distance(t,e)-i.distance(t,s))}GetAttackingEnemies(t){return attackingEnemies=this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(e=>this.IsEnemyAttackingPlanet(e,t)).filter(e=>0===this.gameMap.planetsBetween(e,t).length)}GetAlliesUnderAttacking(){return this.gameMap.myShips.filter(t=>t.isDocked()||t.isDocking()).map(t=>{const e=this.GetEnemiesAroundTarget(t,6*n.MAX_SPEED);let s=0;return e.forEach(e=>{s+=999-i.distance(t,e)}),{ship:t,enemies:e,score:s,count:e.length}}).filter(t=>t.count>0)}GetPlanetUnderAttacking(){const t=this.gameMap.planets.filter(t=>t.isOwnedByMe()),e=this.gameMap.enemyShips.filter(t=>t.isUndocked());let s={};return t.forEach(t=>{e.forEach(e=>{this.IsEnemyAttackingPlanet(e,t)&&(s[t.id]||(s[t.id]=[]),s[t.id].push(e))})}),s}IsShipAroundPlanet(t,e){return i.distance(t,e)<e.radius+n.DOCK_RADIUS+n.PLANET_AROUND_RADIUS}IsEnemyAttackingPlanet(t,e){const s=this.gameMap.previous.shipById(t.id);if(!s)return!1;const a=r.VectorNormalize(t,s),o={x:t.x+a.x*n.MAX_SPEED,y:t.y+a.y*n.MAX_SPEED};return i.intersectSegmentCircle(t,o,e,n.DOCK_RADIUS+n.SHIP_RADIUS+3)||this.IsShipAroundPlanet(t,e)}GetEnemyAngle(t){const e=this.gameMap.previous.shipById(t.id);if(!e)return null;const s=r.VectorNormalize({x:t.x-e.x,y:t.y-e.y}),a={x:t.x+s.x*n.MAX_SPEED,y:t.y+s.y*n.MAX_SPEED};return i.angleInDegree(t,a)}Update(t){this.previousMap?(delete this.previousMap.previous,t.previous=this.previousMap):t.previous=t,this.gameMap=t,this.previousMap=t}}},function(t,e,s){"use strict";const i=s(0),n=s(2),r=(s(1),s(3));class a{static IsCollidesWithObstacleInNextTurn(t,e,s,a){const o=r.PositionInNextTurn(t,e,s);return a.filter(e=>t!=e).some(e=>i.intersectSegmentCircle(t,o,e,t.radius+n.SAFE_DISTANCE))}static AvoidCollidesWithWall(t,e){const s=r.PositionInNextTurn(t,t.speed,t.angle),i=t.radius+n.SAFE_DISTANCE;s.x<=i?t.angle=-90:s.x>=e.width-i?t.angle=90:s.y<=i?t.angle=0:s.y>=e.height-i&&(t.angle=180)}static AvoidCrashWhenMovingToTarget(t,e){e.filter(e=>t!=e).filter(e=>i.distance(t,e)<=2*n.MAX_SPEED+t.radius+e.radius+.2).filter(e=>{const s=r.PositionInNextTurn(t),i=r.PositionInNextTurn(e);return r.IsCollisionTime(t,s,e,i)}).length>0&&t.speed>0?(t.speed=Math.max(0,t.speed-1),a.AvoidCrashWhenMovingToTarget(t,e)):e.push(t)}static AvoidCollidesWithObstacles(t,e){const s=r.PositionInNextTurn(t),o=e.filter(e=>t!=e).filter(e=>i.intersectSegmentCircle(t,s,e,t.radius+n.SAFE_DISTANCE));if(o.length>0){const s=r.GetCenterPointFromGroup(o),n=r.TangentToCircleFromCircle(t,s);if(isNaN(n.p1.x)||isNaN(n.p1.x)||isNaN(n.p1.x)||isNaN(n.p1.x))t.speed>0&&(t.speed=Math.max(0,t.speed-1),a.AvoidCollidesWithObstacles(t,e));else{const s=Math.round(i.angleInDegree(t,n.p1)),o=Math.round(i.angleInDegree(t,n.p2)),h=a.IsCollidesWithObstacleInNextTurn(t,t.speed,s,e),c=a.IsCollidesWithObstacleInNextTurn(t,t.speed,o,e);if(h&&!c||!h&&c)t.angle=h?o:s;else if(h||c)t.speed>0&&(t.speed=Math.max(0,t.speed-1),a.AvoidCollidesWithObstacles(t,e));else{const e=Math.abs(r.AngleBetween(s,t.angle)),i=Math.abs(r.AngleBetween(o,t.angle));t.angle=e<i?s:o}}}}static AvoidCollidesWithEnemies(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const o=r.PositionInNextTurn(t),h=e.filter(e=>t!=e).filter(e=>i.intersectSegmentCircle(t,o,e,t.radius+n.SAFE_DISTANCE));if(h.length>0){const n=r.GetCenterPointFromGroup(h),o=r.TangentToCircleFromCircle(t,n);if(isNaN(o.p1.x)||isNaN(o.p1.x)||isNaN(o.p1.x)||isNaN(o.p1.x))s<40&&(t.angle+=9,a.AvoidCollidesWithEnemies(t,e,++s));else{const n=Math.round(i.angleInDegree(t,o.p1)),h=Math.round(i.angleInDegree(t,o.p2)),c=a.IsCollidesWithObstacleInNextTurn(t,t.speed,n,e),d=a.IsCollidesWithObstacleInNextTurn(t,t.speed,h,e);if(c&&!d||!c&&d)t.angle=c?h:n;else if(c||d)s<40&&(t.angle+=9,a.AvoidCollidesWithEnemies(t,e,++s));else{const e=Math.abs(r.AngleBetween(n,t.angle)),s=Math.abs(r.AngleBetween(h,t.angle));t.angle=e<s?n:h}}}}}t.exports=a},function(t,e,s){"use strict";const i=s(0),n=s(2),r=(s(1),s(7));t.exports=class{constructor(t){this.ship=t,this.speed=0,this.angle=0,this.task="",this.target="",this.distanceToTarget=0}get id(){return this.ship.id}get x(){return this.ship.x}get y(){return this.ship.y}get radius(){return n.SHIP_RADIUS}get ownerId(){return this.ship._ownerId}get dockingStatus(){return this.ship.dockingStatus}get dockedPlanetId(){return this.ship.dockedPlanetId}get dockingProgress(){return this.ship.dockingProgress}get weaponCooldown(){return this.ship.weaponCooldown}isDocked(){return this.ship.dockingStatus===r.DOCKED}isDocking(){return this.ship.dockingStatus===r.DOCKING}isUndocking(){return this.ship.dockingStatus===r.UNDOCKING}isUndocked(){return this.ship.dockingStatus===r.UNDOCKED}canDock(t){return i.distance(this.ship,t)<=n.SHIP_RADIUS+t.radius+n.DOCK_RADIUS&&t.hasDockingSpot()&&(t.isFree()||t.ownerId===this.ship.ownerId)}PrepareForMoveTo(t,e,s){const n=i.reduceEnd(this.ship,t,s),r=i.distance(this.ship,n);this.angle=Math.round(i.angleInDegree(this.ship,n)),this.speed=Math.floor(e<=r?e:r),this.distanceToTarget=r,this.target=t,this.task="move"}PrepareForDockTo(t){this.planet=t,this.task="dock"}DoCommand(){switch(this.task){case"move":return this.ship.thrust(this.speed,this.angle);case"dock":return this.ship.dock(this.planet)}}}},function(t,e,s){"use strict";t.exports={UNDOCKED:0,DOCKING:1,DOCKED:2,UNDOCKING:3}},function(t,e,s){"use strict";const i=s(0);t.exports=class{constructor(t){this._params=t}get id(){return this._params.id}get x(){return this._params.x}get y(){return this._params.y}get radius(){return this._params.radius}get health(){return this._params.health}distanceBetween(t){return i.distance(this,t)}angleBetweenInDegree(t){return i.angleInDegree(this,t)}}},function(t,e,s){"use strict";const i=s(8);t.exports=class extends i{constructor(t,e){super(e),this._params=e,this._gameMap=t}isOwned(){return null!==this.ownerId&&void 0!==this.ownerId}isOwnedByMe(){return this.ownerId===this._gameMap.myPlayerId}isOwnedByEnemy(){return this.isOwned()&&this.ownerId!==this._gameMap.myPlayerId}isFree(){return null===this.ownerId||void 0===this.ownerId}get ownerId(){return this._params.ownerId}get dockingSpots(){return this._params.dockingSpots}hasDockingSpot(){return this.numberOfDockedShips<this._params.dockingSpots}get currentProduction(){return this._params.currentProduction}get remainingProduction(){return this._params.remainingProduction}get dockedShipIds(){return this._params.dockedShipIds}get numberOfDockedShips(){return this.dockedShipIds.length}get dockedShips(){return this._gameMap.shipsByIds(this.dockedShipIds)}toString(){return"planer. "+(this.ownerId?"owner id: "+this.ownerId:"no owner")+": "+JSON.stringify(this._params)}}},function(t,e,s){"use strict";const i=s(1),n=s(14),r=s(13);let a=null;t.exports=class{static start(t){let e=t.botName,s=t.preProcessing,o=t.strategy,h=1;n.readNLines(2,t=>{const c=function(t){const e=parseInt(t[0]),s=t[1].trim().split(" ");return{myPlayerId:e,width:parseInt(s[0]),height:parseInt(s[1])}}(t);i.init(e+c.myPlayerId+".log"),i.log("game meta:"),t.forEach(t=>i.log(t)),i.log(JSON.stringify(c)),a=new r(c),n.readLine(t=>{const r=a.parse(t);i.log("initial map:"),i.log(t),s&&s(r),n.writeLine(e),n.forEachReadLine(t=>{i.log(`turn #${h}, map:`),i.log(t);const e=a.parse(t),s=o(e);n.sendMoves(s.filter(t=>null!==t)),i.log("moves:"),i.log(s.join(" ")),h++})})})}}},function(t,e,s){"use strict";const i=s(4),n=s(17),r=s(18),a=s(19);let o=new n;t.exports={Main:function(t){return i.Update(t),o.Update(t)},Main001:function(t){return i.Update(t),new r(t).Update()},Main002:function(t){return i.Update(t),new a(t).Update()}}},function(t,e,s){"use strict";const i=s(15),n=s(9),r=s(0);s(2);t.exports=class{constructor(t){let e=t.myPlayerId,s=t.width,i=t.height;this._myPlayerId=e,this._width=s,this._height=i,this._playerIds=[],this._planets=[],this._ships=[],this._shipById={},this._enemyShips=[],this._shipsByPlayerId={}}get myPlayerId(){return this._myPlayerId}get width(){return this._width}get height(){return this._height}addPlayerId(t){this._playerIds.push(t)}addPlayerShips(t,e){const s=this._shipsByPlayerId[t]||[],n=e.map(e=>new i(this,t,e));this._shipsByPlayerId[t]=s.concat(n),t!==this.myPlayerId&&(this._enemyShips=this._enemyShips.concat(n)),this._ships=this._ships.concat(n),n.forEach(t=>this._shipById[t.id]=t)}addPlanets(t){this._planets=this._planets.concat(t.map(t=>new n(this,t)))}get numberOfPlayers(){return this._playerIds.length}get allShips(){return this._ships}get myShips(){return this.playerShips(this.myPlayerId)}get enemyShips(){return this._enemyShips}playerShips(t){return this._shipsByPlayerId[t]||[]}shipById(t){return this._shipById[t]}shipsByIds(t){return t.map(t=>this.shipById(t))}get planets(){return this._planets}shipsBetween(t,e){return this._obstaclesBetween(this.allShips,t,e)}myShipsBetween(t,e){return this._obstaclesBetween(this.myShips,t,e)}enemyShipsBetween(t,e){return this._obstaclesBetween(this.enemyShips,t,e)}planetsBetween(t,e){return this._obstaclesBetween(this.planets,t,e)}obstaclesBetween(t,e){return this.shipsBetween(t,e).concat(this.planetsBetween(t,e))}_obstaclesBetween(t,e,s){return t.filter(t=>t.id!==e.id&&t.id!==s.id).filter(t=>r.intersectSegmentCircle(e,s,t,e.radius+.2))}}},function(t,e,s){"use strict";const i=s(12);function n(t,e){const s=[];for(let i=0;i<t;i++)s.push(e(i));return s}t.exports=class{constructor(t){let e=t.myPlayerId,s=t.width,i=t.height;this._myPlayerId=e,this._width=s,this._height=i}parse(t){this._tokens=t.trim().split(" "),this._currentIdx=0,this.map=new i({myPlayerId:this._myPlayerId,width:this._width,height:this._height}),this._parsePlayers(),this._parsePlanets();const e=this._remainingTokens();if(0!==e.length)throw new Error("detected unprocessed remaining tokens: "+e);return this.map}_parsePlayers(){!function(t,e){for(let s=0;s<t;s++)e(s)}(this._nextInt(),()=>{const t=this._nextInt();this.map.addPlayerId(t),this._parseShips(t)})}_parseShips(t){const e=n(this._nextInt(),()=>this._nextShipParams());this.map.addPlayerShips(t,e)}_parsePlanets(){const t=n(this._nextInt(),()=>this._nextPlanetParams());this.map.addPlanets(t)}_nextShipParams(){return{id:this._nextInt(),x:this._nextFloat(),y:this._nextFloat(),health:this._nextInt(),velocityX:this._nextFloat(),velocityY:this._nextFloat(),dockingStatus:this._nextInt(),dockedPlanetId:this._nextInt(),dockingProgress:this._nextInt(),weaponCooldown:this._nextInt()}}_nextPlanetParams(){return{id:this._nextInt(),x:this._nextFloat(),y:this._nextFloat(),health:this._nextInt(),radius:this._nextFloat(),dockingSpots:this._nextInt(),currentProduction:this._nextInt(),remainingProduction:this._nextInt(),ownerId:1===this._nextInt()?this._nextInt():this._skipNextAndReturn(null),dockedShipIds:this._nextDockedShipIds()}}_nextDockedShipIds(){return n(this._nextInt(),()=>this._nextInt())}_nextInt(){return parseInt(this._nextToken())}_nextFloat(){return parseFloat(this._nextToken())}_skipNextAndReturn(t){return this._nextToken(),t}_nextToken(){return this._tokens[this._currentIdx++]}_remainingTokens(){return this._tokens.slice(this._currentIdx)}}},function(t,e,s){"use strict";const i=s(21).createInterface({input:process.stdin,output:process.stdout});class n{static writeLine(t){process.stdout.write(t+"\n")}static sendMoves(t){n.writeLine(t.join(" "))}static readNLines(t,e){const s=[];function n(){i.question("",r)}function r(i){s.push(i),s.length===t?e(s):n()}n()}static readLine(t){n.readNLines(1,e=>t(e[0]))}static forEachReadLine(t){i.on("line",e=>{t(e)})}}t.exports=n},function(t,e,s){"use strict";var i=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])}return t};const n=s(0),r=s(8),a=s(2),o=s(7);t.exports=class extends r{constructor(t,e,s){super(s),this._gameMap=t,this._ownerId=e,this._params=i({health:a.BASE_SHIP_HEALTH,dockingStatus:o.UNDOCKED},s)}isDocked(){return this.dockingStatus===o.DOCKED}isDocking(){return this.dockingStatus===o.DOCKING}isUndocking(){return this.dockingStatus===o.UNDOCKING}isUndocked(){return this.dockingStatus===o.UNDOCKED}canDock(t){return n.distance(this,t)<=a.SHIP_RADIUS+t.radius+a.DOCK_RADIUS&&t.hasDockingSpot()&&(t.isFree()||t.ownerId===this.ownerId)}get ownerId(){return this._ownerId}get dockingStatus(){return this._params.dockingStatus}get radius(){return a.SHIP_RADIUS}get dockedPlanetId(){return this._params.dockedPlanetId}get dockingProgress(){return this._params.dockingProgress}get weaponCooldown(){return this._params.weaponCooldown}pointApproaching(t,e){return n.reduceEnd(this,t,e)}dock(t){return`d ${this.id} ${t.id}`}unDock(){return`u ${this.id}`}thrust(t,e){return`t ${this.id} ${0|t} ${0|e}`}navigate(t){let e=t.target;var s=t.keepDistanceToTarget;let i=void 0===s?0:s,r=t.speed;var a=t.avoidObstacles;let o=void 0===a||a;var h=t.maxCorrections;let c=void 0===h?90:h;var d=t.angularStep;let l=void 0===d?1:d;var p=t.ignoreShips;let u=void 0!==p&&p;var g=t.ignorePlanets;let A=void 0!==g&&g;if(c<=0)return null;if(o&&(u&&A?[]:A||u?u?this._gameMap.planetsBetween(this,e):A?this._gameMap.shipsBetween(this,e):[]:this._gameMap.obstaclesBetween(this,e)).length)return this.navigate({target:n.rotateEnd(this,e,l),keepDistanceToTarget:i,speed:r,avoidObstacles:o,maxCorrections:c-1,angularStep:l,ignoreShips:u,ignorePlanets:A});const m=n.reduceEnd(this,e,i),y=this.distanceBetween(m),S=this.angleBetweenInDegree(m),I=y>=r?r:y;return this.thrust(I,S)}toString(){return"ship. owner id: "+this.ownerId+": "+JSON.stringify(this._params)}}},function(t,e,s){"use strict";s(1),s(0),s(2);const i=s(3);t.exports=class{constructor(t,e){const s=i.GetCenterPointFromGroup(e);this.id=t.id,this.x=s.x,this.y=s.y,this.radius=s.radius,this.entities=e,this.speed=t.speed,this.angle=t.angle,this.distanceToTarget=t.distanceToTarget,e.length}DoCommand(){return this.entities[0],this.entities.map(t=>(t.angle=this.angle,t.speed=this.speed,t.task="move",t.DoCommand()))}}},function(t,e,s){"use strict";const i=s(2),n=s(0),r=(s(1),s(9)),a=s(4),o=s(5),h=s(6);t.exports=class{constructor(){this.abc=!1}Update(t){this.gameMap=t;const e=this.gameMap.myShips.map(t=>new h(t)),s=(this.gameMap.planets.filter(t=>t.isOwnedByMe()).filter(t=>this.gameMap.enemyShips.filter(t=>t.isUndocked()).some(e=>a.IsEnemyAttackingPlanet(e,t))),e.filter(t=>t.isUndocked()).map(t=>{let e=a.GetNearestEnemy(t),s=a.GetNearestPlanet(t),o=null;if(null!=(o=null==e?s:null==s?e:n.distance(t,e)<n.distance(t,s)?e:s.hasDockingSpot()?s:e))return o instanceof r?t.canDock(o)?(t.PrepareForDockTo(o),t):(t.PrepareForMoveTo(o,i.MAX_SPEED,o.radius+t.radius+.05),t):(t.PrepareForMoveTo(o,i.MAX_SPEED,i.WEAPON_RADIUS),t)})),c=[],d=e.concat(this.gameMap.planets);return s.forEach(t=>o.AvoidCollidesWithWall(t,this.gameMap)),s.forEach(t=>o.AvoidCollidesWithObstacles(t,d)),s.sort((t,e)=>t.distanceToTarget-e.distanceToTarget).forEach(t=>{o.AvoidCrashWhenMovingToTarget(t,c)}),s.map(t=>t.DoCommand())}}},function(t,e,s){"use strict";const i=s(2),n=s(0),r=(s(1),s(3),s(4)),a=s(5),o=s(6);t.exports=class{constructor(t){this.gameMap=t,this.maxDistance=n.distance({x:0,y:0},{x:t.width,y:t.height}),this.shipActions={},this.shipAssignToPlanet={},this.shipAssignAttackEnemy={},this.shipAssignDefHarass={}}AddAction(t,e){this.shipActions[t.id]||(this.shipActions[t.id]=[]),this.shipActions[t.id].push(e)}IsShipHasAction(t,e){return this.shipActions[t.id].filter(t=>t.type==e).length>0}AssignShipDockToPlanet(t,e){if(this.shipAssignToPlanet[e.id]||(this.shipAssignToPlanet[e.id]=0),this.shipAssignToPlanet[e.id]<e.dockingSpots){if(this.shipAssignToPlanet[e.id]++,t.canDock(e))this.AddAction(t,{type:"dock",target:e,score:this.maxDistance});else{const s=this.maxDistance-n.distance(t,e);this.AddAction(t,{type:"move",target:e,speed:i.MAX_SPEED,distance:1,score:s})}return!0}return!1}AssignShipAttackEnemy(t,e){let s=this.maxDistance-n.distance(t,e);r.GetAlliesAroundTarget(t).length>1.1*r.GetEnemiesAroundTarget(e).length&&(s*=1.3),this.AddAction(t,{type:"attack",target:e,speed:i.MAX_SPEED,distance:i.WEAPON_RADIUS,score:s})}AssignShipProtectPlanet(t,e){}WhatShouldIDo(t){const e=r.GetSortPlanets(t);if(e.length>0){let s=0,i=e[s];for(;!this.AssignShipDockToPlanet(t,i)&&(s++,e.length>s);)i=e[s]}this.gameMap.planets.filter(t=>t.isOwnedByMe());const s=r.GetSortEnemies(t);s.length>0&&this.AssignShipAttackEnemy(t,s[0]);const a=this.gameMap.enemyShips.filter(t=>t.isDocked()).sort((e,s)=>n.distance(t,e)-n.distance(t,s));if(a.length>0){const e=this.maxDistance-n.distance(t,a[0]);this.AddAction(t,{type:"harass",target:a[0],speed:i.MAX_SPEED,distance:i.WEAPON_RADIUS,score:1.2*e})}return t}Update(){const t=this.gameMap.myShips.map(t=>new o(t)),e=t.filter(t=>t.isUndocked()).map(t=>this.WhatShouldIDo(t));Object.keys(this.shipActions).forEach(e=>{let s=t.filter(t=>t.id==e)[0];const i=this.shipActions[e];if(i.sort((t,e)=>e.score-t.score),i.length>0){const t=i[0];switch(t.type){case"move":case"group":case"attack":case"harass":case"defense":s.PrepareForMoveTo(t.target,t.speed,t.distance);break;case"dock":s.PrepareForDockTo(t.target)}s.action=t.type}});const s=[],r=t.concat(this.gameMap.planets);return e.forEach(t=>{if("harass"==t.action){const e=this.gameMap.enemyShips.filter(t=>t.isUndocked()).map(e=>{const s=n.distance(t,e);return{x:e.x,y:e.y,radius:Math.min(s,i.MAX_SPEED+i.WEAPON_RADIUS)}}).concat(r);a.AvoidCollidesWithEnemies(t,e),t.speed=i.MAX_SPEED}a.AvoidCollidesWithObstacles(t,r)}),e.sort((t,e)=>t.distanceToTarget-e.distanceToTarget).forEach(t=>{a.AvoidCrashWhenMovingToTarget(t,s)}),e.forEach(t=>a.AvoidCollidesWithWall(t,this.gameMap)),e.map(t=>t.DoCommand())}}},function(t,e,s){"use strict";const i=s(2),n=s(0),r=s(1),a=s(3),o=s(4),h=s(5),c=s(6),d=s(16);t.exports=class{constructor(t){this.gameMap=t,this.maxDistance=n.distance({x:0,y:0},{x:t.width,y:t.height}),this.shipActions={},this.shipAssignToPlanet={},this.shipAssignToHarass={},this.shipAssignToAttack={},this.shipAssignDefHarass={},this.planetUnderAttack=o.GetPlanetUnderAttacking(),this.scoreMoveRate=1,this.scoreAttackRate=1,this.scoreDefenseRate=1,this.scoreHarasseRate=1}AddAction(t,e){this.shipActions[t.id]||(this.shipActions[t.id]=[]),this.IsShipHasAction(t,"defense")&&"defense"==e.type||this.shipActions[t.id].push(e)}IsShipHasAction(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this.shipActions[t.id]||(this.shipActions[t.id]=[]),s?this.shipActions[t.id].length>0&&this.shipActions[t.id].sort((t,e)=>e.score-t.score)[0].type==e:this.shipActions[t.id].filter(t=>t.type==e).length>0}IsShipHasNoAction(t){return this.shipActions[t.id]||(this.shipActions[t.id]=[]),0==this.shipActions[t.id].length}AssignShipMoveAndDockToPlanet(t){t.filter(t=>t.isUndocked()).forEach(t=>{const e=this.gameMap.planets.filter(t=>t.isFree()||t.isOwnedByMe()&&t.hasDockingSpot()).map(e=>{let s=this.scoreMoveRate-n.distance(t,e)/this.maxDistance;return s-=.01*o.GetEnemiesAroundTarget(e,5*i.MAX_SPEED).length,this.shipAssignToPlanet[e.id]&&this.shipAssignToPlanet[e.id]>=e.dockingSpots&&(s-=this.maxDistance),{planet:e,score:s}}).sort((t,e)=>e.score-t.score);for(let s=0;s<e.length;s++){const n=e[s].planet,r=e[s].score;if(this.shipAssignToPlanet[n.id]||(this.shipAssignToPlanet[n.id]=0),this.shipAssignToPlanet[n.id]++,t.canDock(n)){if(o.GetEnemiesAroundTarget(n,4*i.MAX_SPEED).length>0)continue;this.AddAction(t,{type:"dock",target:n,score:1});break}this.AddAction(t,{type:"move",target:n,speed:i.MAX_SPEED,distance:1,score:r});break}})}AssignShipAttackEnemy(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t.filter(t=>t.isUndocked()).forEach(t=>{o.GetSortEnemies(t).filter(t=>!a.IsOutOfScreen(t,this.gameMap)).forEach(s=>{if(!this.shipAssignToHarass[s.id]||e){this.shipAssignToAttack[s.id]||(this.shipAssignToAttack[s.id]=0);const e=this.scoreAttackRate-n.distance(t,s)/this.maxDistance-.05*this.shipAssignToAttack[s.id];this.AddAction(t,{type:"attack",target:s,speed:i.MAX_SPEED,distance:i.WEAPON_RADIUS,score:e}),this.shipAssignToAttack[s.id]++}})})}AssignShipProtectDockedAlly(t){const e=o.GetAlliesUnderAttacking();for(let s=0;s<e.length;s++){const r=e[s];r.enemies.forEach((e,s)=>{const o=a.GetCenterPointFromSegment(r.ship,e);if(!this.shipAssignDefHarass[e.id]){const r=t.filter(t=>t.isUndocked()).filter(t=>!this.IsShipHasAction(t,"defense")).sort((t,s)=>n.distance(e,t)-n.distance(e,s));if(r.length>0){const t=r[0],a=this.scoreDefenseRate-n.distance(t,o)/this.maxDistance-.05*s;this.AddAction(t,{type:"defense",target:o,speed:i.MAX_SPEED,distance:0,score:a}),this.shipAssignDefHarass[e.id]=t}}})}}AssignShipHarassEnemies(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.gameMap.enemyShips.filter(t=>t.isDocked()||t.isDocking()).forEach(s=>{const r=t.filter(t=>t.isUndocked()).filter(t=>!this.IsShipHasAction(t,"harass")).sort((t,e)=>n.distance(s,t)-n.distance(s,e));if(r.length>0&&(!this.shipAssignToHarass[s.id]||e)){const t=r[0],e=this.scoreHarasseRate-n.distance(t,s)/this.maxDistance;this.AddAction(t,{type:"harass",target:s,speed:i.MAX_SPEED,distance:i.WEAPON_RADIUS,score:e}),this.shipAssignToHarass[s.id]=t}})}GroupControl(t){const e=[],s=t.filter(t=>this.IsShipHasAction(t,"attack",!0));return s.forEach(t=>{if(!t.isHasGroup){let i=[t];t.isHasGroup=!0,s.filter(e=>e!=t).filter(e=>n.distance(t,e)<=3).forEach(t=>{t.isHasGroup||(i.push(t),t.isHasGroup=!0)}),e.push(new d(t,i))}}),e}Update(){const t=this.gameMap.myShips.map(t=>new c(t));this.AssignShipAttackEnemy(t),this.AssignShipHarassEnemies(t),this.AssignShipProtectDockedAlly(t),this.AssignShipMoveAndDockToPlanet(t),t.filter(t=>t.isUndocked()).some(t=>this.IsShipHasNoAction(t)).length>0&&this.AssignShipAttackEnemy(t,!0),Object.keys(this.shipActions).forEach(e=>{let s=t.filter(t=>t.id==e)[0];const i=this.shipActions[e];if(i.sort((t,e)=>e.score-t.score),i.length>0){const t=i[0];switch(t.type){case"move":case"attack":case"harass":case"defense":s.PrepareForMoveTo(t.target,t.speed,t.distance);break;case"dock":s.PrepareForDockTo(t.target)}s.action=t.type}else r.log(`Ship ${s.id} has no actions!`)});const e=[],s=t.filter(t=>t.isUndocked()&&!t.isHasGroup).concat(e),a=t.filter(t=>!t.isHasGroup).concat(e).concat(this.gameMap.planets);s.forEach(t=>{if("harass"==t.action){const e=this.gameMap.enemyShips.filter(t=>t.isUndocked()).map(e=>{const s=n.distance(t,e);return{x:e.x,y:e.y,radius:Math.min(s,i.MAX_SPEED+i.WEAPON_RADIUS)}}).concat(a);h.AvoidCollidesWithEnemies(t,e)}h.AvoidCollidesWithObstacles(t,a)}),s.forEach(t=>h.AvoidCollidesWithWall(t,this.gameMap));const o=[];s.sort((t,e)=>t.distanceToTarget-e.distanceToTarget).forEach(t=>{h.AvoidCrashWhenMovingToTarget(t,o)});let d=s.map(t=>{if(!t.entities)return t.DoCommand()});return e.forEach(t=>{d=d.concat(t.DoCommand())}),d}}},function(t,e){t.exports=require("fs")},function(t,e){t.exports=require("readline")},function(t,e,s){"use strict";const i=s(10),n=s(1);const r=s(11).Main002;i.start({botName:"Mashimaro 002",preProcessing:t=>{n.log("no data pre-processing performed. number of ships: "+t.myShips.length)},strategy:r})}]);