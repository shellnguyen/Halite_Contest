!function(t){var e={};function s(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,s),i.l=!0,i.exports}s.m=t,s.c=e,s.i=function(t){return t},s.d=function(t,e,n){s.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=19)}([function(t,e,s){"use strict";class n{static distance(t,e){const s=e.x-t.x,n=e.y-t.y;return Math.sqrt(Math.pow(s,2)+Math.pow(n,2))}static angleInRad(t,e){const s=e.x-t.x,n=e.y-t.y,i=Math.atan2(n,s);return i>=0?i:i+2*Math.PI}static angleInDegree(t,e){return n.toDegree(this.angleInRad(t,e))}static rotateEnd(t,e,s){const i=n.distance(t,e),r=n.angleInDegree(t,e)+s,a=n.toRad(r),o=Math.cos(a)*i,h=Math.sin(a)*i;return{x:t.x+o,y:t.y+h}}static reduceEnd(t,e,s){const i=n.angleInRad(t,e),r=Math.cos(i)*s,a=Math.sin(i)*s;return{x:e.x-r,y:e.y-a}}static toDegree(t){return 180*t/Math.PI}static toRad(t){return t*Math.PI/180}static intersectSegmentCircle(t,e,s,i){const r=e.x-t.x,a=e.y-t.y,o=Math.pow(r,2)+Math.pow(a,2);if(0===o)return n.distance(t,e)<=s.radius+i;const h=-2*(Math.pow(t.x,2)-t.x*e.x-t.x*s.x+e.x*s.x+Math.pow(t.y,2)-t.y*e.y-t.y*s.y+e.y*s.y),c=Math.min(-h/(2*o),1);if(c<0)return!1;const d=t.x+r*c,l=t.y+a*c;return n.distance({x:d,y:l},s)<=s.radius+i}}t.exports=n},function(t,e,s){"use strict";const n=s(17);let i;t.exports=class{static init(t){i=n.createWriteStream(t,{flags:"w"})}static log(t){i.write(t+"\n")}}},function(t,e,s){"use strict";t.exports={MAX_SPEED:7,SHIP_RADIUS:.5,MAX_SHIP_HEALTH:255,BASE_SHIP_HEALTH:255,WEAPON_COOLDOWN:1,WEAPON_RADIUS:5,WEAPON_DAMAGE:64,EXPLOSION_RADIUS:10,DOCK_RADIUS:4,DOCK_TURNS:5,BASE_PRODUCTIVITY:6,SPAWN_RADIUS:2}},function(t,e,s){"use strict";const n=s(0),i=s(2);s(1);t.exports=new class{constructor(){this.previousMap=null,this.bestPlanet=null,this.bestPlanetShipGo=0,i.PLANET_AROUND_RADIUS=i.MAX_SPEED+i.WEAPON_RADIUS+2*i.SHIP_RADIUS,i.SAFE_DISTANCE=.1}VectorNormalize(t){const e=Math.sqrt(t.x*t.x+t.y*t.y);return{x:t.x/e,y:t.y/e}}VectorFromSpeedAngle(t,e){const s=n.toRad(e);return{x:t*Math.cos(s),y:t*Math.sin(s)}}TangentToCircleFromCircle(t,e){const s=e.x-t.x,n=e.y-t.y,r=Math.sqrt(s*s+n*n),a=Math.asin(e.radius/r),o=Math.atan2(n,s),h=t.radius+e.radius+i.SHIP_RADIUS+i.SAFE_DISTANCE,c=o-a,d=o+a;return{p1:{x:e.x+h*Math.sin(c),y:e.y-h*Math.cos(c)},p2:{x:e.x-h*Math.sin(d),y:e.y+h*Math.cos(d)}}}AngleBetween(t,e){return this.Mod(e-t+180,360)-180}Mod(t,e){return t-Math.floor(t/e)*e}GetNearestPlanet(t){const e=this.gameMap.planets.filter(t=>t.isFree()||t.isOwnedByMe()&&t.hasDockingSpot()).sort((e,s)=>n.distance(t,e)-n.distance(t,s));return e.length>0?e[0]:null}GetSortPlanets(t){return this.gameMap.planets.filter(t=>t.isFree()||t.isOwnedByMe()&&t.hasDockingSpot()).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetMyPlanets(t){return this.gameMap.planets.filter(t=>t.isOwnedByMe()).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetNearestEnemy(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this.SortEnemyByDistance(t);return e<s.length?s[e]:null}GetNearestShip(t){return this.gameMap.myShips.filter(t=>t.isUndocked()).sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetAttackingEnemies(t){return this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(e=>this.IsEnemyAttackingPlanet(e,t)).filter(e=>0===this.gameMap.planetsBetween(e,t).length)}SortEnemyByDistance(t){return this.gameMap.enemyShips.sort((e,s)=>n.distance(t,e)-n.distance(t,s))}GetEnemiesAroundTarget(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50;return this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(s=>n.distance(s,t)<e).length}GetAlliesAroundTarget(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:25;return this.gameMap.myShips.filter(t=>t.isUndocked()).filter(s=>n.distance(s,t)<e).length}IsShipAroundPlanet(t,e){return n.distance(t,e)<e.radius+i.DOCK_RADIUS+i.PLANET_AROUND_RADIUS}IsEnemyAttackingPlanet(t,e){const s=this.gameMap.previous.shipById(t.id);if(!s)return!1;const r=this.VectorNormalize({x:t.x-s.x,y:t.y-s.y}),a={x:t.x+r.x*i.MAX_SPEED,y:t.y+r.y*i.MAX_SPEED};return n.intersectSegmentCircle(t,a,e,i.DOCK_RADIUS+i.SHIP_RADIUS+3)||this.IsShipAroundPlanet(t,e)}GetEnemyAngle(t){const e=this.gameMap.previous.shipById(t.id);if(!e)return null;const s=this.VectorNormalize({x:t.x-e.x,y:t.y-e.y}),r={x:t.x+s.x*i.MAX_SPEED,y:t.y+s.y*i.MAX_SPEED};return n.angleInDegree(t,r)}Update(t){this.previousMap?(delete this.previousMap.previous,t.previous=this.previousMap):t.previous=t,this.gameMap=t,this.previousMap=t}}},function(t,e,s){"use strict";t.exports={UNDOCKED:0,DOCKING:1,DOCKED:2,UNDOCKING:3}},function(t,e,s){"use strict";const n=s(0);t.exports=class{constructor(t){this._params=t}get id(){return this._params.id}get x(){return this._params.x}get y(){return this._params.y}get radius(){return this._params.radius}get health(){return this._params.health}distanceBetween(t){return n.distance(this,t)}angleBetweenInDegree(t){return n.angleInDegree(this,t)}}},function(t,e,s){"use strict";const n=s(5);t.exports=class extends n{constructor(t,e){super(e),this._params=e,this._gameMap=t}isOwned(){return null!==this.ownerId&&void 0!==this.ownerId}isOwnedByMe(){return this.ownerId===this._gameMap.myPlayerId}isOwnedByEnemy(){return this.isOwned()&&this.ownerId!==this._gameMap.myPlayerId}isFree(){return null===this.ownerId||void 0===this.ownerId}get ownerId(){return this._params.ownerId}get dockingSpots(){return this._params.dockingSpots}hasDockingSpot(){return this.numberOfDockedShips<this._params.dockingSpots}get currentProduction(){return this._params.currentProduction}get remainingProduction(){return this._params.remainingProduction}get dockedShipIds(){return this._params.dockedShipIds}get numberOfDockedShips(){return this.dockedShipIds.length}get dockedShips(){return this._gameMap.shipsByIds(this.dockedShipIds)}toString(){return"planer. "+(this.ownerId?"owner id: "+this.ownerId:"no owner")+": "+JSON.stringify(this._params)}}},function(t,e,s){"use strict";const n=s(0),i=s(2),r=(s(1),s(3));class a{static PositionInNextTurn(t,e,s){const n=r.VectorFromSpeedAngle(e||t.speed,s||t.angle);return{x:t.x+n.x,y:t.y+n.y}}static IsTwoLinesIntersect(t,e,s,n){let i=e.x-t.x,r=e.y-t.y,a=n.x-s.x,o=n.y-s.y,h=(-r*(t.x-s.x)+i*(t.y-s.y))/(-a*r+i*o),c=(+a*(t.y-s.y)-o*(t.x-s.x))/(-a*r+i*o);return h>=0&&h<=1&&c>=0&&c<=1}static IsCollidesWithObstacleInNextTurn(t,e,s,r){const o=a.PositionInNextTurn(t,e,s);return r.filter(e=>t!=e).some(e=>n.intersectSegmentCircle(t,o,e,i.SHIP_RADIUS+i.SAFE_DISTANCE))}static AvoidCollidesWithWall(t,e){const s=a.PositionInNextTurn(t,t.speed,t.angle);s.x<=0?t.angle=-90:s.x>=e.width?t.angle=90:s.y<=0?t.angle=0:s.y>=e.height&&(t.angle=180)}static AvoidCrashWhenMovingToTarget(t,e){e.filter(e=>t.id!=e.id).filter(e=>n.distance(t,e)<=2*(i.MAX_SPEED+i.SHIP_RADIUS)).filter(e=>{const s=a.PositionInNextTurn(t),r=a.PositionInNextTurn(e),o=n.distance(s,r)<=2*i.SHIP_RADIUS+1||a.IsTwoLinesIntersect(t,s,e,r);return o}).length>0&&t.speed>0&&(t.angle,t.speed=Math.max(0,t.speed-1),a.AvoidCrashWhenMovingToTarget(t,e))}static AvoidCollidesWithObstacles(t,e){const s=a.PositionInNextTurn(t);e.filter(e=>t!=e).filter(e=>n.intersectSegmentCircle(t,s,e,i.SHIP_RADIUS+i.SAFE_DISTANCE)).forEach(s=>{const i=r.TangentToCircleFromCircle(t,s),o=n.angleInDegree(t,i.p1),h=n.angleInDegree(t,i.p2),c=a.IsCollidesWithObstacleInNextTurn(t,t.speed,o,e),d=a.IsCollidesWithObstacleInNextTurn(t,t.speed,h,e);let l=0;if(c&&!d||!c&&d)l=c?h:o;else{l=Math.abs(r.AngleBetween(o,t.angle))<Math.abs(r.AngleBetween(h,t.angle))?o:h}c&&d?t.speed>0&&(t.speed=Math.max(0,t.speed-1),a.AvoidCollidesWithObstacles(t,e)):t.angle=l})}static AvoidCollidesWithEnemies(t,e){const s=a.PositionInNextTurn(t);e.filter(e=>n.distance(t,e)<2*i.MAX_SPEED).filter(e=>{const n=r.GetEnemyAngle(e);if(null!=n){const r=a.PositionInNextTurn(e,i.MAX_SPEED,n);return r.radius=i.SHIP_RADIUS,e.nextTurn=r,a.IsTwoLinesIntersect(t,s,e,r)}return!1}).forEach(s=>{const i=r.TangentToCircleFromCircle(t,s.nextTurn),o=Math.floor(n.angleInDegree(t,i.p1)),h=Math.floor(n.angleInDegree(t,i.p2))+1,c=a.IsCollidesWithObstacleInNextTurn(t,t.speed,o,e),d=a.IsCollidesWithObstacleInNextTurn(t,t.speed,h,e);let l=0;if(c&&!d||!c&&d)l=c?h:o;else{l=Math.abs(r.AngleBetween(o,t.angle))<Math.abs(r.AngleBetween(h,t.angle))?o:h}c&&d?t.speed>0&&(t.speed=Math.max(0,t.speed-1),a.AvoidCollidesWithObstacles(t,e)):t.angle=l})}}t.exports=a},function(t,e,s){"use strict";const n=s(0),i=s(2),r=(s(1),s(4));t.exports=class{constructor(t){this.ship=t,this.speed=0,this.angle=0,this.action="",this.target=""}get id(){return this.ship.id}get x(){return this.ship.x}get y(){return this.ship.y}get radius(){return i.SHIP_RADIUS}get ownerId(){return this.ship._ownerId}get dockingStatus(){return this.ship.dockingStatus}get dockedPlanetId(){return this.ship.dockedPlanetId}get dockingProgress(){return this.ship.dockingProgress}get weaponCooldown(){return this.ship.weaponCooldown}isDocked(){return this.ship.dockingStatus===r.DOCKED}isDocking(){return this.ship.dockingStatus===r.DOCKING}isUndocking(){return this.ship.dockingStatus===r.UNDOCKING}isUndocked(){return this.ship.dockingStatus===r.UNDOCKED}canDock(t){return n.distance(this.ship,t)<=i.SHIP_RADIUS+t.radius+i.DOCK_RADIUS&&t.hasDockingSpot()&&(t.isFree()||t.ownerId===this.ship.ownerId)}PrepareForMoveTo(t,e,s){const i=n.reduceEnd(this.ship,t,s),r=n.distance(this.ship,i);this.angle=n.angleInDegree(this.ship,i),this.speed=e<=r?e:r,this.action="move"}PrepareForDockTo(t){this.planet=t,this.action="dock"}DoCommand(){switch(this.action){case"move":return this.ship.thrust(this.speed,this.angle);case"dock":return this.ship.dock(this.planet)}}}},function(t,e,s){"use strict";const n=s(1),i=s(13),r=s(12);let a=null;t.exports=class{static start(t){let e=t.botName,s=t.preProcessing,o=t.strategy,h=1;i.readNLines(2,t=>{const c=function(t){const e=parseInt(t[0]),s=t[1].trim().split(" ");return{myPlayerId:e,width:parseInt(s[0]),height:parseInt(s[1])}}(t);n.init(e+c.myPlayerId+".log"),n.log("game meta:"),t.forEach(t=>n.log(t)),n.log(JSON.stringify(c)),a=new r(c),i.readLine(t=>{const r=a.parse(t);n.log("initial map:"),n.log(t),s&&s(r),i.writeLine(e),i.forEachReadLine(t=>{n.log(`turn #${h}, map:`),n.log(t);const e=a.parse(t),s=o(e);i.sendMoves(s.filter(t=>null!==t)),n.log("moves:"),n.log(s.join(" ")),h++})})})}}},function(t,e,s){"use strict";const n=s(3),i=s(15),r=s(16);t.exports={Main:function(t){return n.Update(t),new i(t).Update()},MainImprove:function(t){return n.Update(t),new r(t).Update()}}},function(t,e,s){"use strict";const n=s(14),i=s(6),r=s(0);s(2);t.exports=class{constructor(t){let e=t.myPlayerId,s=t.width,n=t.height;this._myPlayerId=e,this._width=s,this._height=n,this._playerIds=[],this._planets=[],this._ships=[],this._shipById={},this._enemyShips=[],this._shipsByPlayerId={}}get myPlayerId(){return this._myPlayerId}get width(){return this._width}get height(){return this._height}addPlayerId(t){this._playerIds.push(t)}addPlayerShips(t,e){const s=this._shipsByPlayerId[t]||[],i=e.map(e=>new n(this,t,e));this._shipsByPlayerId[t]=s.concat(i),t!==this.myPlayerId&&(this._enemyShips=this._enemyShips.concat(i)),this._ships=this._ships.concat(i),i.forEach(t=>this._shipById[t.id]=t)}addPlanets(t){this._planets=this._planets.concat(t.map(t=>new i(this,t)))}get numberOfPlayers(){return this._playerIds.length}get allShips(){return this._ships}get myShips(){return this.playerShips(this.myPlayerId)}get enemyShips(){return this._enemyShips}playerShips(t){return this._shipsByPlayerId[t]||[]}shipById(t){return this._shipById[t]}shipsByIds(t){return t.map(t=>this.shipById(t))}get planets(){return this._planets}shipsBetween(t,e){return this._obstaclesBetween(this.allShips,t,e)}myShipsBetween(t,e){return this._obstaclesBetween(this.myShips,t,e)}enemyShipsBetween(t,e){return this._obstaclesBetween(this.enemyShips,t,e)}planetsBetween(t,e){return this._obstaclesBetween(this.planets,t,e)}obstaclesBetween(t,e){return this.shipsBetween(t,e).concat(this.planetsBetween(t,e))}_obstaclesBetween(t,e,s){return t.filter(t=>t.id!==e.id&&t.id!==s.id).filter(t=>r.intersectSegmentCircle(e,s,t,e.radius+.2))}}},function(t,e,s){"use strict";const n=s(11);function i(t,e){const s=[];for(let n=0;n<t;n++)s.push(e(n));return s}t.exports=class{constructor(t){let e=t.myPlayerId,s=t.width,n=t.height;this._myPlayerId=e,this._width=s,this._height=n}parse(t){this._tokens=t.trim().split(" "),this._currentIdx=0,this.map=new n({myPlayerId:this._myPlayerId,width:this._width,height:this._height}),this._parsePlayers(),this._parsePlanets();const e=this._remainingTokens();if(0!==e.length)throw new Error("detected unprocessed remaining tokens: "+e);return this.map}_parsePlayers(){!function(t,e){for(let s=0;s<t;s++)e(s)}(this._nextInt(),()=>{const t=this._nextInt();this.map.addPlayerId(t),this._parseShips(t)})}_parseShips(t){const e=i(this._nextInt(),()=>this._nextShipParams());this.map.addPlayerShips(t,e)}_parsePlanets(){const t=i(this._nextInt(),()=>this._nextPlanetParams());this.map.addPlanets(t)}_nextShipParams(){return{id:this._nextInt(),x:this._nextFloat(),y:this._nextFloat(),health:this._nextInt(),velocityX:this._nextFloat(),velocityY:this._nextFloat(),dockingStatus:this._nextInt(),dockedPlanetId:this._nextInt(),dockingProgress:this._nextInt(),weaponCooldown:this._nextInt()}}_nextPlanetParams(){return{id:this._nextInt(),x:this._nextFloat(),y:this._nextFloat(),health:this._nextInt(),radius:this._nextFloat(),dockingSpots:this._nextInt(),currentProduction:this._nextInt(),remainingProduction:this._nextInt(),ownerId:1===this._nextInt()?this._nextInt():this._skipNextAndReturn(null),dockedShipIds:this._nextDockedShipIds()}}_nextDockedShipIds(){return i(this._nextInt(),()=>this._nextInt())}_nextInt(){return parseInt(this._nextToken())}_nextFloat(){return parseFloat(this._nextToken())}_skipNextAndReturn(t){return this._nextToken(),t}_nextToken(){return this._tokens[this._currentIdx++]}_remainingTokens(){return this._tokens.slice(this._currentIdx)}}},function(t,e,s){"use strict";const n=s(18).createInterface({input:process.stdin,output:process.stdout});class i{static writeLine(t){process.stdout.write(t+"\n")}static sendMoves(t){i.writeLine(t.join(" "))}static readNLines(t,e){const s=[];function i(){n.question("",r)}function r(n){s.push(n),s.length===t?e(s):i()}i()}static readLine(t){i.readNLines(1,e=>t(e[0]))}static forEachReadLine(t){n.on("line",e=>{t(e)})}}t.exports=i},function(t,e,s){"use strict";var n=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&(t[n]=s[n])}return t};const i=s(0),r=s(5),a=s(2),o=s(4);t.exports=class extends r{constructor(t,e,s){super(s),this._gameMap=t,this._ownerId=e,this._params=n({health:a.BASE_SHIP_HEALTH,dockingStatus:o.UNDOCKED},s)}isDocked(){return this.dockingStatus===o.DOCKED}isDocking(){return this.dockingStatus===o.DOCKING}isUndocking(){return this.dockingStatus===o.UNDOCKING}isUndocked(){return this.dockingStatus===o.UNDOCKED}canDock(t){return i.distance(this,t)<=a.SHIP_RADIUS+t.radius+a.DOCK_RADIUS&&t.hasDockingSpot()&&(t.isFree()||t.ownerId===this.ownerId)}get ownerId(){return this._ownerId}get dockingStatus(){return this._params.dockingStatus}get radius(){return a.SHIP_RADIUS}get dockedPlanetId(){return this._params.dockedPlanetId}get dockingProgress(){return this._params.dockingProgress}get weaponCooldown(){return this._params.weaponCooldown}pointApproaching(t,e){return i.reduceEnd(this,t,e)}dock(t){return`d ${this.id} ${t.id}`}unDock(){return`u ${this.id}`}thrust(t,e){return`t ${this.id} ${0|t} ${0|e}`}navigate(t){let e=t.target;var s=t.keepDistanceToTarget;let n=void 0===s?0:s,r=t.speed;var a=t.avoidObstacles;let o=void 0===a||a;var h=t.maxCorrections;let c=void 0===h?90:h;var d=t.angularStep;let l=void 0===d?1:d;var p=t.ignoreShips;let u=void 0!==p&&p;var g=t.ignorePlanets;let I=void 0!==g&&g;if(c<=0)return null;if(o&&(u&&I?[]:I||u?u?this._gameMap.planetsBetween(this,e):I?this._gameMap.shipsBetween(this,e):[]:this._gameMap.obstaclesBetween(this,e)).length)return this.navigate({target:i.rotateEnd(this,e,l),keepDistanceToTarget:n,speed:r,avoidObstacles:o,maxCorrections:c-1,angularStep:l,ignoreShips:u,ignorePlanets:I});const m=i.reduceEnd(this,e,n),y=this.distanceBetween(m),_=this.angleBetweenInDegree(m),S=y>=r?r:y;return this.thrust(S,_)}toString(){return"ship. owner id: "+this.ownerId+": "+JSON.stringify(this._params)}}},function(t,e,s){"use strict";const n=s(2),i=s(0),r=s(1),a=s(6),o=s(3),h=s(7),c=s(8);t.exports=class{constructor(t){this.gameMap=t}Update(){const t=this.gameMap.myShips.map(t=>new c(t)),e=(this.gameMap.planets.filter(t=>t.isOwnedByMe()).filter(t=>this.gameMap.enemyShips.filter(t=>t.isUndocked()).some(e=>o.IsEnemyAttackingPlanet(e,t))),t.filter(t=>t.isUndocked()).map(t=>{let e=o.GetNearestEnemy(t),s=o.GetNearestPlanet(t),r=null;if(null!=(r=null==e?s:null==s?e:i.distance(t,e)<i.distance(t,s)?e:s.hasDockingSpot()?s:e))return r instanceof a?t.canDock(r)?(t.PrepareForDockTo(r),t):(t.PrepareForMoveTo(r,n.MAX_SPEED,r.radius+t.radius+.05),t):(t.PrepareForMoveTo(r,n.MAX_SPEED,n.WEAPON_RADIUS),t)}));r.log("cccccccccccccccc");const s=e.filter(t=>t instanceof c),d=t.concat(this.gameMap.planets);return s.forEach(t=>h.AvoidCollidesWithWall(t,this.gameMap)),s.forEach(t=>h.AvoidCollidesWithObstacles(t,d)),s.forEach(t=>h.AvoidCrashWhenMovingToTarget(t,s)),e.map(t=>t.DoCommand())}}},function(t,e,s){"use strict";const n=s(2),i=s(0),r=(s(1),s(3)),a=s(7),o=s(8);t.exports=class{constructor(t){this.gameMap=t,this.maxDistance=i.distance({x:0,y:0},{x:t.width,y:t.height}),this.shipActions={},this.shipAssignToPlanet={}}AddAction(t,e){this.shipActions[t.id]||(this.shipActions[t.id]=[]),"attack"==e.type&&(e.score*=2),this.shipActions[t.id].push(e)}AssignShipDockToPlanet(t,e){if(this.shipAssignToPlanet[e.id]||(this.shipAssignToPlanet[e.id]=0),this.shipAssignToPlanet[e.id]<e.dockingSpots){if(this.shipAssignToPlanet[e.id]++,t.canDock(e))this.AddAction(t,{type:"dock",target:e,score:999});else{const s=this.maxDistance-i.distance(t,e);this.AddAction(t,{type:"move",target:e,speed:n.MAX_SPEED,distance:1,score:s})}return!0}return!1}AssignShipToProtectPlanet(t,e){let s=null;(e.dockedShips.length=1)?s=e.dockedShips[0]:e.dockedShips.length;{const t=e.dockedShips.sort((t,e)=>t.x-e.x).map(t=>t.x),n=e.dockedShips.sort((t,e)=>t.y-e.y).map(t=>t.y),i={x:t[0],y:n[0],width:t[t.length-1]-t[0],height:n[n.length-1]-n[0]};s={x:i.x+i.width/2,y:i.y+i.height/2,radius:Math.sqrt(i.width*i.width+i.height*i.height)}}if(null!=s){const r=this.maxDistance-i.distance(t,e);this.AddAction(t,{type:"defense",target:s,speed:n.MAX_SPEED,distance:1,score:r})}}WhatShouldIDo(t){const e=r.GetSortPlanets(t);if(e.length>0){let s=0,n=e[s];for(;!this.AssignShipDockToPlanet(t,n)&&(s++,e.length>s);)n=e[s]}let s=this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(t=>r.GetEnemiesAroundTarget(t,10)>=r.GetAlliesAroundTarget(t,10)).filter(e=>i.distance(t,e)<2*n.MAX_SPEED);if(s.length>0){let e=this.gameMap.myShips.filter(t=>t.isUndocked()).sort((e,s)=>i.distance(t,e)-i.distance(t,s));if(e[0].length>0){const s=this.maxDistance-i.distance(t,e[0]);this.AddAction(t,{type:"run",target:e[0],speed:n.MAX_SPEED,distance:2*n.SHIP_RADIUS+.1,score:s})}else{const e=r.GetEnemyAngle(s[0]);if(null!=e){const s=a.PositionInNextTurn(t,n.MAX_SPEED,e);s.radius=0;const r=this.maxDistance-i.distance(t,s);this.AddAction(t,{type:"run",target:s,speed:n.MAX_SPEED,distance:0,score:r})}}}if((s=this.gameMap.enemyShips.filter(t=>t.isUndocked()).filter(t=>r.GetEnemiesAroundTarget(t,10)<r.GetAlliesAroundTarget(t,10)).filter(e=>i.distance(t,e)<4*n.MAX_SPEED)).length>0){const e=this.maxDistance-i.distance(t,s[0]);this.AddAction(t,{type:"attack",target:s[0],speed:n.MAX_SPEED,distance:n.WEAPON_RADIUS,score:e})}if((s=this.gameMap.enemyShips.filter(t=>!t.isUndocked()).sort((e,s)=>i.distance(t,e)-i.distance(t,s))).length>0){const e=this.maxDistance-i.distance(t,s[0]);this.AddAction(t,{type:"harass",target:s[0],speed:n.MAX_SPEED,distance:n.WEAPON_RADIUS,score:e})}r.GetMyPlanets(t).forEach(e=>{r.GetEnemiesAroundTarget(e)>r.GetAlliesAroundTarget(e)&&i.distance(t,e)<2*n.MAX_SPEED&&this.AssignShipToProtectPlanet(t,e)})}Update(){const t=this.gameMap.myShips.map(t=>new o(t));t.filter(t=>t.isUndocked()).map(t=>{this.WhatShouldIDo(t)}),Object.keys(this.shipActions).forEach(e=>{const s=t.filter(t=>t.id==e)[0],n=this.shipActions[e];if(n.sort((t,e)=>e.score-t.score),n.length>0){const t=n[0];switch(t.type){case"move":case"run":case"attack":case"harass":case"defense":s.PrepareForMoveTo(t.target,t.speed,t.distance);break;case"dock":s.PrepareForDockTo(t.target)}}});const e=t.concat(this.gameMap.planets);return t.filter(t=>t.isUndocked()).map(s=>(a.AvoidCollidesWithWall(s,this.gameMap),a.AvoidCollidesWithObstacles(s,e),a.AvoidCrashWhenMovingToTarget(s,t),s.DoCommand()))}GetScoreByAction(t){switch(t){case"move":return 2;case"dock":return 3;case"defense":return 4;case"harass":return this.gameMap.planets.filter(t=>t.isOwnedByMe()),this.gameMap.planets.filter(t=>t.isOwnedByEnemy()),2.5;case"run":return 3.5;case"attack":return 5}}}},function(t,e){t.exports=require("fs")},function(t,e){t.exports=require("readline")},function(t,e,s){"use strict";const n=s(9),i=s(1);const r=s(10).MainImprove;n.start({botName:"Mashimaro Improve",preProcessing:t=>{i.log("no data pre-processing performed. number of ships: "+t.myShips.length)},strategy:r})}]);